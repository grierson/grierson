= Test Driven Development (TDD)

Tests continually add constraints to code making the code fit the specification, but tests can only prove wrong not that the program is right.

== Benefits
* Peak - Andres Ericsson
** Specific goal
** Fast feedback
** Pomodoro sized for focus
* Acts a regression testing so you can refactor
* Ensures certain edge case (common business cases) are covered
* Acts as documentation
* Easier to write than Property Based

== Cons
* Crashing into barriers to end up where you need to go, no thought how you go there. (Transformation Priority Premise is just a PREMISE) 
* Can't prove program is correct
* 100% Test coverage doesn't mean program is correct 
* Not as tougher as Property based test
  ** Diamond kata
  ** Highlight bugs/edge cases you didn't think of
 
== Test Constraints

* Readable
** Write the test you want to read
** Names should be a clear scenario and expectation
** Given When Then is a good structure but don't constraint yourself to it
*** Given a Delivery has a past date Then it is invalid
*** Given player 2 has 0 points When player 2 scores Then player 2 should have 15 points

* Isolated
** No side effects 
** No shared global state (Database) because of race conditions

* Fast
** Full test suite should run under a ~second

== Order of test
. What test should I write?

.. Degenerate cases
* nil, empty, 0, default, etc..

.. Simple cases
* One element (Sort kata)
* A row (Diamond kata)
* All 0 (Bowling kata) 
* Handle new line `(wrap 1 "aa")` (word wrap)

.. Specific cases
* Strike (Bowling kata)
* Word is mid line break `(wrap 3 "a bb"` (word wrap)  


== How to write tests
Three laws of TDD:: 
Follow the laws

Assert first:: 
Prioritize what you want to prove first. Then let errors grow the arrange, act, and code.

One-To-Many::
If collection, handle single element first then handle collection

== How should I write my code?
Transformation Priority Premise::
Apply transformations to production code

Fake it til you make it (Triangulation)::
Use basic implementations then add more and more logic the more tests you add (As the tests get more specific the code gets more generic)

== How to handle Collaborators
* Classical
  ** Stub shared collaborators (Database, File System)
  ** Blackbox testing
* London
  ** Stub all queries except values 
  ** Spy all commands
  ** Whitebox testing

== Examples

=== Word wrap
. Degenerate cases
   * Bad input returns empty string
     ** `(wrap 1 nil) => ""`
     ** `(wrap 1 "") => ""`
   * Space at start of string returns string without space
     ** `(wrap 1 " a") => "a"`
. Simple -> Complex cases
   * Input length is less than width so return input
     ** `(wrap 1 "a") => "a"`
   * Line split puts each string on to a new line
     ** `(wrap 1 "a\nb") => "a\nb"`
   * Line split mid word keeps word intact
     ** `(wrap 3 "a bb") => "a\nbb"`

=== Invert name
. Degenerate cases
   * Bad input returns empty string
     ** `(invert nil) => ""`
     ** `(invert "") => ""`
. Simple -> Complex cases
   * Invert first and last name
     ** `(invert "First Last") => "Last, First"`
   * Ignore honorific
     ** `(invert "Mr. First Last") => "Last, First"`
   * Keep post nominal
     ** `(invert "First Last Phd.") => "Last, First Phd."`
