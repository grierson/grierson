= Transformation Priority Premise

[cols="2,2,3"]
|===
| Transformation                 | Description                                          | Example

| {} → nil                       | no code at all → code that employs nil
a|
[source,clojure]
----
;; 1: Write test (Still test expected outcome and handling degenerate test case first)
(= (wrap nil 10) "")

;; 2: Write code (Ensuring unit test is failing)
(defn wrap [s l] nil)
----

| nil → constant                 | nil -> [], 0, ""
a|
[source,clojure]
----
;; Now we can make it pass (Law 3)
(defn wrap [s l] "")
----

| constant → constant+           | a simple constant to a more complex constant
a|
[source,clojure]
----
???
----

| constant → scalar              | replacing a constant with a variable or an argument
a|
[source,clojure]
----
(= (wrap "" 10) "")
(= (wrap "word" 10) "word")

(defn foo [x] x)
----


| statement → statements         | adding more unconditional statements.
a|
[source,clojure]
----
???
----

| unconditional → if             | splitting the execution path
a|
[source,clojure]
----
;; 1: Testing a short word
(= (wrap "word" 10) "word")

;; 2: Write code (Ensuring unit test is failing)
(defn wrap [s l]
  (if (nil? s)
    ""
    s))
----

| scalar → array                 |
a|
[source,clojure]
----
(defn foo [x] x)
----

| array → container              |
a|
[source,clojure]
----
(defn foo [x] x)
----

| statement → tail-recursion     |
a|
[source,clojure]
----
(defn foo [x] x)
----

| if → while                     |
a|
[source,clojure]
----
(defn foo [x] x)
----

| statement → non-tail-recursion |
a|
[source,clojure]
----
(defn foo [x] x)
----

| expression → function          | replacing an expression with a function or algorithm
a|
[source,clojure]
----
(= (wrap "word word" 6) "word\nword")

(defn wrap [s l]
  (if (nil? s)
    ""
    (str/replace s #" " "\n")))
----

| variable → assignment          | replacing the value of a variable.
a|
[source,clojure]
----
(defn foo [x] x)
----

| case                           | adding a case (or else) to an existing switch or if
a|
[source,clojure]
----
(defn foo [x] x)
----
|===
